diff --git a/Makefile b/Makefile
index 06eea5d..41717c7 100644
--- a/Makefile
+++ b/Makefile
@@ -15,6 +15,7 @@ OBJS = \
 	picirq.o\
 	pipe.o\
 	proc.o\
+	ring_buf.o\
 	sleeplock.o\
 	spinlock.o\
 	string.o\
diff --git a/proc.c b/proc.c
index 806b1b1..5d1e24d 100644
--- a/proc.c
+++ b/proc.c
@@ -110,6 +110,7 @@ found:
   sp -= sizeof *p->context;
   p->context = (struct context*)sp;
   memset(p->context, 0, sizeof *p->context);
+  memset(p->bufpages, 0, sizeof p->bufpages);
   p->context->eip = (uint)forkret;
 
   return p;
diff --git a/proc.h b/proc.h
index 1647114..76daeb3 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  char* bufpages[9];           // Ring buf data, if initialized
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/ring_buf.c b/ring_buf.c
new file mode 100644
index 0000000..64e36b5
--- /dev/null
+++ b/ring_buf.c
@@ -0,0 +1,38 @@
+#include "types.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "defs.h"
+#include "x86.h"
+
+const uint buf_sz = 8 * PGSIZE;
+
+int *ntaken = (int *)0x0000f000;
+char *buf = (char *)0x0000f000 + PGSIZE;
+
+int
+buf_put(char *data, uint len)
+{
+	if (len > buf_sz)
+		return -1;
+	
+	// if we're full
+	if (*ntaken == 8)
+		return -1;
+
+	return 0;
+}
+
+int
+buf_get(char *data, uint len, uint maxlen)
+{
+	if (len > buf_sz)
+		return -1;
+
+	// if we're empty
+	if (*ntaken == 0)
+		return -1;
+
+	return 0;
+}
diff --git a/ring_buf.h b/ring_buf.h
new file mode 100644
index 0000000..79943cd
--- /dev/null
+++ b/ring_buf.h
@@ -0,0 +1,2 @@
+int	buf_put(char *, uint);
+int	buf_get(char *, uint, uint);
diff --git a/syscall.c b/syscall.c
index ee85261..f09c857 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_buf_setup(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_buf_setup] sys_buf_setup,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..c0b17cb 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_buf_setup 22
diff --git a/sysproc.c b/sysproc.c
index 0686d29..cd856c8 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -7,6 +7,8 @@
 #include "mmu.h"
 #include "proc.h"
 
+int mappages(pde_t *, void *, uint, uint, int);
+
 int
 sys_fork(void)
 {
@@ -89,3 +91,27 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_buf_setup(void)
+{
+	int i, j, e;
+	char *va;
+
+	if (myproc()->bufpages[0] != 0)
+		return -1;
+
+	for (i = 0; i < 9; i++) {
+		if ((myproc()->bufpages[i] = kalloc()) == 0) {
+			for (j = 0; j < i; j++)
+				kfree(myproc()->bufpages[j]);
+		}
+	}
+	for (i = 0, va = (char *)0x0000f000; i < 9; i++, va += PGSIZE) {
+		e = mappages(myproc()->pgdir, va, PGSIZE, V2P(myproc()->bufpages[i]), PTE_P | PTE_W | PTE_U);
+		if (e == -1)
+			return -1;	// TODO: unmap and deallocate all eight pages
+	}
+
+	return 0;
+}
diff --git a/user.h b/user.h
index f45b8d5..548171c 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int buf_setup(void);
 
 // ulib.c
 int stat(char*, struct stat*);
diff --git a/usertests.c b/usertests.c
index a1e97e7..9a69215 100644
--- a/usertests.c
+++ b/usertests.c
@@ -13,6 +13,15 @@ char name[3];
 char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
 int stdout = 1;
 
+void
+buftest(void)
+{
+	if (buf_setup() == -1) {
+		printf(stdout, "buf_setup failed\n");
+		exit();
+	}
+}
+
 // does chdir() call iput(p->cwd) in a transaction?
 void
 iputtest(void)
@@ -1756,6 +1765,8 @@ main(int argc, char *argv[])
   }
   close(open("usertests.ran", O_CREATE));
 
+  buftest();
+
   argptest();
   createdelete();
   linkunlink();
diff --git a/usys.S b/usys.S
index 8bfd8a1..a7eb182 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(buf_setup)
diff --git a/vm.c b/vm.c
index 3f71b6a..f623aa3 100644
--- a/vm.c
+++ b/vm.c
@@ -57,7 +57,7 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
-static int
+int
 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 {
   char *a, *last;
