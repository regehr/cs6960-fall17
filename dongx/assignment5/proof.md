**Prove that xv6 always pre-empts process to schedule other runnable ones if there are any.**
When the system boots, the bootloader will lead the kernel to the `main(void)` function in `main.c` in a early stage. It will first set up physical page allocator, kernel memory page table and then directly jump into `mpinit(void)` defined in `mp.c`. `mpinit(void)` will set up the `lapic` array for each processor. Then, the `main(void)` function in `main.c` will call `lapicinit(void)` in which a timer interupt is set ot be triggered periodically. Note that this is happen on the processor that runs the `main()` function. To make it run on all processors, OS then calls `startothers(void)` function defined in `main.c` where a piece of entry code is set to all other cores. The entry code for those processor is defined in `mpmain(void)` where `lapicinit(void)` is called as well on another core. As a result, if the system boots properly, each core will trigger a time interupt periodically.

Note that the interupt system may be disabled by `pushcli` and re-enabled by `popcli` for various reasons like avoiding deadlock and protect process information. Nevertheless, this will only last for a short period and won't disable the interupt subsystem forever.

Assume the lapic will eventually deliver its time interupts. Since the timer interupts are set up on each processor as described above, each processor will eventually receive one. Upon receive a timer interupt generated by APIC, CPU will jump to the corresponding trap vector defined in IDT (which is also initialized in `main.c` by calling `tvinit(void)`). The trap vector will lead the system to `alltraps` in `trapasm.S` for building the trap frame and then call `trap(struct trapframe*)` defined in `trap.c`.

In `trap(struct trapframe*)`, if we find it is a timer interupt, two corresponding logic may be triggered:
1. If the time interupt is triggered on CPU0, it then increase variable `ticks` and call `wakeup(&ticks)`.
2. If the system found some process is **running** on this processor when the time interupt delivered, it will force the current process to yield by calling `yield(void)` defined in `proc.c`.

The second routine will lead the system jump to `yield(void)` where the current process state is set to `RUNNABLE` and switch back to the scheduler so that it can find the next `RUNNABLE` process to run.

Combining the fact that the timer interuption are fired asynchronously independent from any user processes and the assumption that the timer interupt will eventually delivered, xv6 will eventually yield the current running process and jump back to the scheduler so that other runnable process will be run.