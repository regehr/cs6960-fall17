/*********************************************************************
 *
 * Alan Humphrey
 * u0487406
 * CS6960, Spring 2017
 * Assignement_1:  pipetest.c
 *
 *
 *********************************************************************/

#include "types.h"
#include "stat.h"
#include "user.h"

#define READ       0
#define WRITE      1
#define BUF_SIZE   512
#define NUM_BYTES  1048576
#define NUM_TESTS  10

// function forward decls
void single_process_test(unsigned int * in, unsigned int * out);
void  multi_process_test(unsigned int * in, unsigned int * out);

// taken from https://en.wikipedia.org/wiki/Xorshift
unsigned int xorshift32(unsigned int state[static 1]);

// taken from usertests.c
unsigned int rand(unsigned int randstate);



// ==============================================================
//
int
main( void )
{

  // test with one process
  for (unsigned int i = 0; i < NUM_TESTS; ++i) {

    // this will be our 1MB of random bytes to agree upon for write/read checks
    unsigned int * in_bytes  = malloc(NUM_BYTES);

    // fill up the random bytes (generate unsigned int)
    unsigned int state[1] = { 1u };
    for (unsigned int i = 0; i < NUM_BYTES; ++i) {
      in_bytes[i] = xorshift32(state);
    }


    // this will be what we write to.... check against bytes in "in_bytes"
    unsigned int* out_bytes = (unsigned int*)malloc(sizeof(unsigned int) * NUM_BYTES);

    // initialize each element to 0
    for (unsigned int i = 0; i < NUM_BYTES; ++i) {
      out_bytes[i] = 0u;
    }

    single_process_test(in_bytes, out_bytes);

    // compare pipe written/read bytes against generated bytes
    for (unsigned int i = 0; i < NUM_BYTES; ++i) {
      if (in_bytes[i] != out_bytes[i]) {
        exit();
      }
    }

    // free up memory
    free(in_bytes);
    free(out_bytes);
  }

  printf(1, "\nsingle_process_tests: PASSED\n\n");



  //==================================================================


  // test with one writer and multiple readers
  for (unsigned int i = 0; i < NUM_TESTS; ++i) {

    // this will be our 1MB of random bytes to agree upon for write/read checks
    unsigned int* in_bytes = (unsigned int*)malloc(sizeof(unsigned int) * NUM_BYTES);

    // fill up the random bytes (generate unsigned int)
    unsigned int state[1] = { 1u };
    for (unsigned int i = 0; i < NUM_BYTES; ++i) {
      in_bytes[i] = xorshift32(state);
    }

    // this will be what we write to.... check against bytes in "in_bytes"
    unsigned int* out_bytes = (unsigned int*)malloc(sizeof(unsigned int) * NUM_BYTES);

    // initialize each element to 0
    for (unsigned int i = 0; i < NUM_BYTES; ++i) {
      out_bytes[i] = 0u;
    }

    multi_process_test(in_bytes, out_bytes);

    // compare pipe written/read bytes against generated bytes
    for (unsigned int i = 0; i < NUM_BYTES; ++i) {
      if (in_bytes[i] != out_bytes[i]) {
        exit();
      }
    }

    // free up memory
    free(in_bytes);
    free(out_bytes);
  }

  printf(1, "\nmulti_process_tests: PASSED\n\n");


  return 0;

}


// ==============================================================
// The state word must be initialized to non-zero
unsigned int
xorshift32(unsigned int state[static 1])
{
  unsigned int x = state[0];
  x ^= x << 13;
  x ^= x >> 17;
  x ^= x << 5;
  state[0] = x;
  return x;
}


// ==============================================================
//
unsigned int
rand(unsigned int randstate)
{
  randstate = randstate * 1664525 + 1013904223;
  return randstate;
}


// ==============================================================
//
void
single_process_test(unsigned int * in, unsigned int * out)
{
  // fds[READ] is set up for reading, fds[WRITE] is set up for writing
  int fds[2];

  if (pipe(fds) == -1) {
    printf(2, "Pipe failed");
    exit();
  }

  int bytes_written = 0;
  int bytes_read    = 0;
  int write_offset  = 0;
  int read_offset   = 0;

  for (int i = 0; i < NUM_BYTES; ++i) {
    int rand_size = (rand(1) % BUF_SIZE) / sizeof(int);
    bytes_written = write(fds[WRITE], in + write_offset, rand_size);
    bytes_read    = read(fds[READ],  out + read_offset, rand_size);
    write_offset += bytes_written;
    read_offset  += bytes_read;
  }

  close(fds[0]);
  close(fds[1]);

}



// ==============================================================
//
void multi_process_test(unsigned int * in, unsigned int * out)
{
  // fds[READ] is set up for reading ,  fds[WRITE] is set up for writing
  int fds[2];
  int pid = getpid();

  if (pipe(fds) == -1) {
    printf(2, "Pipe failed");
    exit();
  }

  for (unsigned int i = 0; i < NUM_BYTES; ++i) {

    // parent process
    if (pid == getpid()) {
      close(fds[READ]);  // close the READ end

      int total_bytes_written = 0;

      while (total_bytes_written < NUM_BYTES) {
        int rand_write_size = (rand(1) % BUF_SIZE) / sizeof(int);

        int curr_written = write(fds[WRITE], in, rand_write_size * sizeof(int));

        if (curr_written < 0) {
          printf(2, "pipe write failed. \n");
        }
        total_bytes_written += curr_written;
      }
      close(fds[WRITE]);
    }

    // child processs
    else {
      close(fds[WRITE]);  // close the WRITE end

      int total_bytes_read = 0;

      while (total_bytes_read < NUM_BYTES) {
        int rand_read_size = (rand(1) % BUF_SIZE) / sizeof(int);

        // Read the data.
        int curr_read = read(fds[READ], out, rand_read_size * sizeof(int));

        if (curr_read < 0) {
          printf(2, "pipe read filed. \n");
          exit();
        }
        total_bytes_read += curr_read;
      }
      close(fds[READ]);
      exit();
    }
  }

  wait();

}

